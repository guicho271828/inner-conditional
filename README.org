* Inner-Conditional

 - Series of macros which optimize the inner conditional jumps
   of looping, iterating, anything
 - Extensible syntaxes and helper macros
 - A kind of idea as `compile-time continuation'

** Usage

The condition checking is done only once.
#+BEGIN_SRC LISP
(ql:quickload :iterate)
(use-package :iterate)

(defun test0 (flag)
  (with-inner (body)
    (iter (for i from 0 to 5)
          (print i)
          (inner (body)
            (if flag
                (body (princ "loop on"))
                (body (princ "loop off")))))))

INNER-CONDITIONAL-TEST> (test0 t)

0 loop on
1 loop on
2 loop on
3 loop on
4 loop on
5 loop on
#+END_SRC

** Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.1.2 on X86-64 Linux  3.2.0-39-generic (author's environment)

Also, it depends on the following libraries:

+ ITERATE  ::
    Jonathan Amsterdam's iterator/gatherer/accumulator facility

+ ALEXANDRIA  ::
    Alexandria is a collection of portable public domain utilities.

+ CL-ANNOT by Tomohiro Matsuyama ::
    Python-like Annotation Syntax for Common Lisp

+ CL-SYNTAX by m2ym ::
    Reader Syntax Coventions for Common Lisp and SLIME

+ Optima by m2ym :: 
    Optimized Pattern Matching Library for Common Lisp
    
** Installation

+ First grab the code with =git clone git://github.com/guicho271828/inner-conditional.git=
+ Put it in your local-project folder
+ open slime REPL
+ =(ql:register-local-projects)=
+ =(ql:quickload :inner-conditional)= and the library will be
  installed along with the dependencies

** Author

+ Masataro Asai (guicho2.71828@gmail.com)

* Concepts and API

Removing conditional jumps in loops are one of the easiest way to
optimize the loop. The number of checks should be minimized, and the
checking variables in a smaller loop may well be a large
bottleneck. Yet, some code would yield a bad-looking result of that
optimization, since the semantics of the code best fits the code which
has conditional jumps in a smaller loop. Luckily, Common Lisp has
macros, which provides the ability to walk on and modify the code
tree. So we can keep the code clean and at the same time get a
faster result.

** How it works

Below is a result of macroexpand-1 of the =with-inner= code in the
usage example. You would see how it works.

#+BEGIN_SRC LISP
(MACROLET ((BODY (&REST INNER-CONDITIONAL::SEXP)
             (SUBST `(PROGN ,@INNER-CONDITIONAL::SEXP) '#:CONDITIONAL-TAG1364
                    '(WITH-INNER (BODY)
                       (ITER
                         (FOR I FROM 0 TO 5)
                         (PRINT I)
                         #:CONDITIONAL-TAG1364)))))
  (IF FLAG
      (BODY (PRINC "loop on"))
      (BODY (PRINC "loop off"))))
#+END_SRC

macroexpand the =with-inner= in the macroexpantion code again, then we
get the code below:

#+BEGIN_SRC LISP
(MACROLET ((BODY (&REST INNER-CONDITIONAL::SEXP)
             (SUBST `(PROGN ,@INNER-CONDITIONAL::SEXP) '#:CONDITIONAL-TAG1365
                    '(PROGN
                      (ITER
                        (FOR I FROM 0 TO 5)
                        (PRINT I)
                        #:CONDITIONAL-TAG1365)))))
  (IF FLAG
      (BODY (PRINC "loop on"))
      (BODY (PRINC "loop off"))))
#+END_SRC

The semantics of =body= is similar to the continuation, so personally
I call it as a compile-time continuation. It may sound odd but
everything's in the right place isnt it? 

As the name suggests, its actual implementation is different from what
is normally called as continuation since =body= is not a function at
all. It is because this library is meant for speed, not for the
cleanness in the theory. Macroexpansion has no drawbacks in run-time
so it is better than defining the body with =lambda= or =flet=.

** Macro (with-inner (label) &body body)

Simply, the macro =with-inner= creates many versions of (looping)
programs, move the conditional jumps to the first entry and run the
chosen version of those codes. Inside each program the jump code is
deleted. =with-inner= is the very place where the conditional clauses
written in =inner= (described below) is actually expanded.

** Local Macro-like clause, or sometimes a Macro, (inner (label) conditional-clause)

Inside the body of =with-inner=, you can specify a certain code to be
out of the loop with =inner=. If =inner= is placed not within the body
of =with-inner=, it just expands =`(,label ,@body)= to =`(progn
,@body)=. Note that =conditional-clause= should be only one
S-exp. There is no limitation in the expression of
=conditional-clause= but =when= needs a special care. For example,

#+BEGIN_SRC LISP
(inner (body)
  (when <condition>
    (body (dosomething))))
#+END_SRC

will be expanded like this:

#+BEGIN_SRC LISP
(inner (body)
  (if <condition>
      (body (dosomething))
      (body nil)))
#+END_SRC

This is because the actual body of the loop is expanded by the *local
macro* bounded to =label= (in the abouve example it is
=body=). Without the code modification shown above, if =<condition>=
fails the loop code will not be run at all.

** Using the different layers of =with-inner=

The local macro is bounded to =label=, so you are able to use the
different layers at the same time by specifying multiple =with-inner= s
with different =label= s. 

#+BEGIN_SRC LISP
(defun test0 (flag)
  (with-inner (body)
    (loop for i from 0 to 5
       do (with-inner (body2)
            (loop for j from 0 to 5
                 do
                 (format t "~%i: ~a j: ~a" i j)
                 (inner (body2)
                   (if (evenp i)
                       (body2 (format t "  i is even"))
                       (body2 (format t "  i is odd"))))
                 (inner (body)
                   (if flag
                       (body (format t "  loop on"))
                       (body (format t "  loop off")))))))))
#+END_SRC

However unfortunately,
=with-inner= won't work with my favorite =iterate= library, since
=iter= macro signals an error when it finds =macrolet= in the body of
the code.

** Using other kinds of clauses

Once you have understood how it works, you don't have to be afraid to
use other conditional clauses like =cond=, =case=, etc. All you have to do
is calling =label= .

#+BEGIN_SRC LISP
(defun test2 (arg)
  (let ((count 0))
    (with-inner (body)
      (iter
        (for i from 0 to 5)
        (inner (body)
          (case (progn (incf count)
                       (mod arg 3))
            (0 (body (format t "divided. i*3 =~a~%"
                             (* i 3))))
            (1 (body (format t "modulo 1. i*3 + 1 =~a~%"
                             (+ 1 (* i 3)))))
            (2 (body (format t "modulo 2. i*3 + 2 =~a~%"
                             (+ 2 (* i 3)))))))))
    (is count 1 "the condition is checked only once")))

(test2 0)
(test2 1)
(test2 2)
#+END_SRC

** And some predefined clauses

OK, you may want to use a normal-looking clauses similar to =when= or
=cond= and not to use a combination of =inner= and local macro bounded
to =label=. In that case, use =inner-when= or =inner-if= etc.

: (inner-if label condition then else)
: (inner-when label condition &body body)
: (inner-cond label &body clauses)
: (inner-case label keyform &body cases)
: (inner-ecase label keyform &body cases)
: (inner-ccase label keyform &body cases)
: (inner-typecase label keyform &body cases)

similar macros can be defined with =define-inner-conditional=.

Usage Example:

#+BEGIN_SRC LISP
(define-inner-conditional inner-when label (condition &body body)
  `(when ,condition
	 (,label ,@body)))
#+END_SRC

Then the macroexpantion of

#+BEGIN_SRC LISP
(inner-when label <condition>
  (dosomething)
  (dosomething))
#+END_SRC

is

#+BEGIN_SRC LISP
(INNER (LABEL)
  (WHEN <CONDITION>
    (LABEL (DOSOMETHING)
           (DOSOMETHING))))
#+END_SRC

Just simple. Simple!
If you have any question with how it works, try some macroexpand-1,
or C-c C-m (slime-expand-1).

** Use with your own library

If you write a macro which expands to a code which always checks a
certain dynamic variable then this library may help you write an
extension which minimizes the number of checking in the expanded code.

For example:

#+BEGIN_SRC LISP
(defvar *output-stream* nil)
(defmacro sample (&body body)
  `(if *output-stream*
       (progn ,@body)
       (with-output-to-string (*output-stream*)
         ,@body)))
#+END_SRC

In this sample, =body= is meant to output some string to a stream
which is dynamically bound. By default, =*output-stream*= is bound to
nil and the the result is output as a string. Similar technique is
used in =[[https://github.com/arielnetworks/cl-markup][cl-markup]]= for example. 
In some cases a user should run a loop over that macro.

#+BEGIN_SRC LISP
(loop for i from 0 to 5
      do (sample (print i *output-stream*)))
#+END_SRC

The author may want to divide that conditional part of the code, but
until now there is no standardized way to do that. Now I show you
a version using this library.

#+BEGIN_SRC LISP
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *sample-label* 'sample-label)) ;; an identifier

(defvar *output-stream* nil)

(define-condition-expander
    (sample *sample-label* *output-stream-definite-here*
            :force-single-check t
            :version-expander version)
    (&body body)
  `(if (progn
         (format t "condition checked")
         *output-stream*)
       ,(version 'either-is-ok `(progn ,@body))
       (with-output-to-string (*output-stream*)
         ,(version 'either-is-ok `(progn ,@body)))))

(defun test2 ()
  (*output-stream-definite-here*
    (loop for i from 0 to 5
       do
         (sample
           (format *output-stream* "hello!")))
    (loop for i from 0 to 5
       do
         (sample
           (format *output-stream* "bye!")))))
#+END_SRC

In the above example, the user doesn't have to think about the
conditional jumping within =sample= *and at the same time* the jump
is checked only once. Below is the iterative results of macroexpansion.

#+BEGIN_SRC LISP
(SYMBOL-MACROLET ((INNER-CONDITIONAL::*CURRENT-VERSION* NIL))
  (WITH-INNER (SAMPLE-LABEL :FORCE-SINGLE-CHECK T)
    (LOOP FOR I FROM 0 TO 5
          DO (SAMPLE
               (FORMAT *OUTPUT-STREAM* "hello!")))
    (LOOP FOR I FROM 0 TO 5
          DO (SAMPLE
               (FORMAT *OUTPUT-STREAM* "bye!")))))

-->

(SYMBOL-MACROLET ((INNER-CONDITIONAL::*CURRENT-VERSION* NIL))
  (MACROLET ((SAMPLE-LABEL (INNER-CONDITIONAL::ID &REST INNER-CONDITIONAL::SEXP)
               `(MACROLET ((#:TAG1273 ,NIL
                             `(PROGN ,',@INNER-CONDITIONAL::SEXP)))
                  (SYMBOL-MACROLET ((INNER-CONDITIONAL::*CURRENT-VERSION*
                                     ,INNER-CONDITIONAL::ID))
                    (WITH-INNER (SAMPLE-LABEL :FORCE-SINGLE-CHECK T)
                      (LOOP FOR I FROM 0 TO 5
                            DO (#:TAG1273))
                      (LOOP FOR I FROM 0 TO 5
                            DO (SAMPLE
                                 (FORMAT *OUTPUT-STREAM* "bye!"))))))))
    (WITH-VERSIONS INNER-CONDITIONAL::*CURRENT-VERSION*
        ((EITHER-IS-OK
          (SAMPLE-LABEL EITHER-IS-OK (PROGN (FORMAT *OUTPUT-STREAM* "hello!")))))
      (IF (PROGN (FORMAT T "condition checked") *OUTPUT-STREAM*)
          EITHER-IS-OK
          (WITH-OUTPUT-TO-STRING (*OUTPUT-STREAM*) EITHER-IS-OK)))))

-->

(SYMBOL-MACROLET ((INNER-CONDITIONAL::*CURRENT-VERSION* NIL))
  (MACROLET ((SAMPLE-LABEL (INNER-CONDITIONAL::ID &REST INNER-CONDITIONAL::SEXP)
               `(MACROLET ((#:TAG1273 ,NIL
                             `(PROGN ,',@INNER-CONDITIONAL::SEXP)))
                  (SYMBOL-MACROLET ((INNER-CONDITIONAL::*CURRENT-VERSION*
                                     ,INNER-CONDITIONAL::ID))
                    (MACROLET ((SAMPLE-LABEL (INNER-CONDITIONAL::ID &REST INNER-CONDITIONAL::SEXP)
                                 `(MACROLET ((#:TAG1274 ,NIL
                                               `(PROGN ,',@INNER-CONDITIONAL::SEXP)))
                                    (SYMBOL-MACROLET ((INNER-CONDITIONAL::*CURRENT-VERSION*
                                                       ,INNER-CONDITIONAL::ID))
                                      (WITH-INNER (SAMPLE-LABEL :FORCE-SINGLE-CHECK T)
                                        (LOOP FOR I FROM 0 TO 5
                                              DO (#:TAG1273))
                                        (LOOP FOR I FROM 0 TO 5
                                              DO (#:TAG1274)))))))
                      (WITH-VERSIONS INNER-CONDITIONAL::*CURRENT-VERSION*
                          ((EITHER-IS-OK
                            (SAMPLE-LABEL EITHER-IS-OK (PROGN (FORMAT *OUTPUT-STREAM* "bye!")))))
                        (IF (PROGN (FORMAT T "condition checked") *OUTPUT-STREAM*)
                            EITHER-IS-OK
                            (WITH-OUTPUT-TO-STRING (*OUTPUT-STREAM*) EITHER-IS-OK))))))))
    (WITH-VERSIONS INNER-CONDITIONAL::*CURRENT-VERSION*
        ((EITHER-IS-OK
          (SAMPLE-LABEL EITHER-IS-OK (PROGN (FORMAT *OUTPUT-STREAM* "hello!")))))
      (IF (PROGN (FORMAT T "condition checked") *OUTPUT-STREAM*)
          EITHER-IS-OK
          (WITH-OUTPUT-TO-STRING (*OUTPUT-STREAM*) EITHER-IS-OK)))))
#+END_SRC

Therefore the expansion result is equivalent to something like this:

#+BEGIN_SRC LISP
(IF (PROGN (FORMAT T "condition checked") *OUTPUT-STREAM*)
    (PROGN
       (LOOP FOR I FROM 0 TO 5
             DO (PROGN (FORMAT *OUTPUT-STREAM* "hello!")))
       (LOOP FOR I FROM 0 TO 5
             DO (PROGN (FORMAT *OUTPUT-STREAM* "bye!"))))
    (WITH-OUTPUT-TO-STRING (*OUTPUT-STREAM*)
       (LOOP FOR I FROM 0 TO 5
             DO (PROGN (FORMAT *OUTPUT-STREAM* "hello!")))
       (LOOP FOR I FROM 0 TO 5
             DO (PROGN (FORMAT *OUTPUT-STREAM* "bye!")))))
#+END_SRC

* Copyright

Copyright (c) 2013 Masataro Asai (guicho2.71828@gmail.com)


* License

Licensed under the LLGPL License.

