* Inner-Conditional

 - Series of macros which optimizes the inner conditional jumps
   of looping, iterating, anything
 - Extensible syntaxes and helper macros
 - A kind of idea as `compile-time continuation'

** Usage

#+BEGIN_SRC LISP
(defun test0 (flag)
  (with-inner (body)
    (iter (for i from 0 to 5)
          (print i)
          (inner (body)
            (if flag
                (body (princ "loop on"))
                (body (princ "loop off")))))))

INNER-CONDITIONAL-TEST> (test0 t)

0 loop on
1 loop on
2 loop on
3 loop on
4 loop on
5 loop on
#+END_SRC

Now, this is the macroexpand-1 of the =with-inner= code above.
You would see how it works.
The condition checking is done only once.

#+BEGIN_SRC LISP
(MACROLET ((BODY (&REST INNER-CONDITIONAL::SEXP)
             (SUBST `(PROGN ,@INNER-CONDITIONAL::SEXP) '#:CONDITIONAL-TAG1364
                    '(WITH-INNER (BODY)
                       (ITER
                         (FOR I FROM 0 TO 5)
                         (PRINT I)
                         #:CONDITIONAL-TAG1364)))))
  (IF FLAG
      (BODY (PRINC "loop on"))
      (BODY (PRINC "loop off"))))
#+END_SRC

macroexpand again, then we get the code below:

#+BEGIN_SRC LISP

(MACROLET ((BODY (&REST INNER-CONDITIONAL::SEXP)
             (SUBST `(PROGN ,@INNER-CONDITIONAL::SEXP) '#:CONDITIONAL-TAG1365
                    '(PROGN
                      (ITER
                        (FOR I FROM 0 TO 5)
                        (PRINT I)
                        #:CONDITIONAL-TAG1365)))))
  (IF FLAG
      (BODY (PRINC "loop on"))
      (BODY (PRINC "loop off"))))
#+END_SRC


** Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.1.2 on X86-64 Linux  3.2.0-39-generic (author's environment)

Also, it depends on the following libraries:

+ ITERATE  ::
    Jonathan Amsterdam's iterator/gatherer/accumulator facility

+ ALEXANDRIA  ::
    Alexandria is a collection of portable public domain utilities.

+ CL-ANNOT by Tomohiro Matsuyama ::
    Python-like Annotation Syntax for Common Lisp

+ CL-SYNTAX by m2ym ::
    Reader Syntax Coventions for Common Lisp and SLIME

+ Optima by m2ym :: 
    Optimized Pattern Matching Library for Common Lisp
    
** Installation

+ First grab the code with =git clone git@github.com:guicho271828/inner-conditional.git=
+ Put it in local-project folder
+ open slime REPL
+ =(ql:quickload :inner-conditional)= and the library will be installed along with all
  the dependencies

** Author

+ Masataro Asai (guicho2.71828@gmail.com)

* Concepts and API

Removing conditional jumps in loops are one of the easiest way to
optimize the loop. The number of checks should be minimized, and the
checking variables in a smaller loop may well be a large
bottleneck. Yet, some code would yield a bad-looking result of that
optimization, since the semantics of the code best fits the code
which has conditional jumps in a smaller loop. Luckily, Common Lisp
has macros and modifies the looking of the code and I worked a bit
on it.

**  Macro (with-inner (label) &body body)

Simply, the macro =with-inner= creates many versions of (looping)
programs, move the conditional jumps to the first entry and run one of
those codes. Inside each program the jump code is deleted. Just
simple.

** Macro (inner (label) conditional-clause)

Inside the body of =with-inner=, you can specify a certain
code to be out of the loop with =inner=. Note that conditional-clause
should be only one S-exp. Any expression is ok, but =when= needs
a special care. For example,

#+BEGIN_SRC LISP
(inner (body)
  (when <condition>
    (body (dosomething))))
#+END_SRC

will be expanded like this:

#+BEGIN_SRC LISP
(inner (body)
  (if <condition>
      (body (dosomething))
      (body nil)))
#+END_SRC

This is because the actual body of the loop is expanded by the local
macro bounded to =body=. In this case, if =<condition>= fails the loop
code will not be run at all unless there is a code-modification. The
local macro is bounded to =label=, so you are able to use different
layers at the same time.

#+BEGIN_SRC LISP
(defun test0 (flag)
  (with-inner (body)
    (loop for i from 0 to 5
       do (with-inner (body2)
            (loop for j from 0 to 5
                 do
                 (format t "~%i: ~a j: ~a" i j)
                 (inner (body2)
                   (if (evenp i)
                       (body2 (format t "  i is even"))
                       (body2 (format t "  i is odd"))))
                 (inner (body)
                   (if flag
                       (body (format t "  loop on"))
                       (body (format t "  loop off")))))))))

#+END_SRC

* Copyright

Copyright (c) 2013 Masataro Asai (guicho2.71828@gmail.com)


* License

Licensed under the LLGPL License.

