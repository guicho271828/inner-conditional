* Inner-Conditional

 - Series of macros which optimize the inner conditional jumps
   of looping, iterating, anything
 - Extensible syntaxes and helper macros
 - A kind of idea as `compile-time continuation'

** Usage

#+BEGIN_SRC LISP
(defun test0 (flag)
  (with-inner (body)
    (iter (for i from 0 to 5)
          (print i)
          (inner (body)
            (if flag
                (body (princ "loop on"))
                (body (princ "loop off")))))))

INNER-CONDITIONAL-TEST> (test0 t)

0 loop on
1 loop on
2 loop on
3 loop on
4 loop on
5 loop on
#+END_SRC

Now, this is the macroexpand-1 of the =with-inner= code above.
You would see how it works.
The condition checking is done only once.

#+BEGIN_SRC LISP
(MACROLET ((BODY (&REST INNER-CONDITIONAL::SEXP)
             (SUBST `(PROGN ,@INNER-CONDITIONAL::SEXP) '#:CONDITIONAL-TAG1364
                    '(WITH-INNER (BODY)
                       (ITER
                         (FOR I FROM 0 TO 5)
                         (PRINT I)
                         #:CONDITIONAL-TAG1364)))))
  (IF FLAG
      (BODY (PRINC "loop on"))
      (BODY (PRINC "loop off"))))
#+END_SRC

macroexpand again, then we get the code below:

#+BEGIN_SRC LISP

(MACROLET ((BODY (&REST INNER-CONDITIONAL::SEXP)
             (SUBST `(PROGN ,@INNER-CONDITIONAL::SEXP) '#:CONDITIONAL-TAG1365
                    '(PROGN
                      (ITER
                        (FOR I FROM 0 TO 5)
                        (PRINT I)
                        #:CONDITIONAL-TAG1365)))))
  (IF FLAG
      (BODY (PRINC "loop on"))
      (BODY (PRINC "loop off"))))
#+END_SRC


** Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.1.2 on X86-64 Linux  3.2.0-39-generic (author's environment)

Also, it depends on the following libraries:

+ ITERATE  ::
    Jonathan Amsterdam's iterator/gatherer/accumulator facility

+ ALEXANDRIA  ::
    Alexandria is a collection of portable public domain utilities.

+ CL-ANNOT by Tomohiro Matsuyama ::
    Python-like Annotation Syntax for Common Lisp

+ CL-SYNTAX by m2ym ::
    Reader Syntax Coventions for Common Lisp and SLIME

+ Optima by m2ym :: 
    Optimized Pattern Matching Library for Common Lisp
    
** Installation

+ First grab the code with =git clone git@github.com:guicho271828/inner-conditional.git=
+ Put it in your local-project folder
+ open slime REPL
+ =(ql:quickload :inner-conditional)= and the library will be installed along with all
  the dependencies

** Author

+ Masataro Asai (guicho2.71828@gmail.com)

* Concepts and API

Removing conditional jumps in loops are one of the easiest way to
optimize the loop. The number of checks should be minimized, and the
checking variables in a smaller loop may well be a large
bottleneck. Yet, some code would yield a bad-looking result of that
optimization, since the semantics of the code best fits the code which
has conditional jumps in a smaller loop. Luckily, Common Lisp has
macros, providing the ability to freely modify the looking of the
code. I just worked a bit on it.

**  Macro (with-inner (label) &body body)

Simply, the macro =with-inner= creates many versions of (looping)
programs, move the conditional jumps to the first entry and run the
chosen version of those codes. Inside each program the jump code is
deleted. Just simple.

** Local Macro-like clause (inner (label) conditional-clause)

Inside the body of =with-inner=, you can specify a certain
code to be out of the loop with =inner=. Note that conditional-clause
should be only one S-exp. Any expression is ok, but =when= needs
a special care. For example,

#+BEGIN_SRC LISP
(inner (body)
  (when <condition>
    (body (dosomething))))
#+END_SRC

will be expanded like this:

#+BEGIN_SRC LISP
(inner (body)
  (if <condition>
      (body (dosomething))
      (body nil)))
#+END_SRC

This is because the actual body of the loop is expanded by the *local
macro* bounded to =body=. In this case, if =<condition>= fails the
loop code will not be run at all unless there is a
code-modification. The local macro is bounded to =label=, so you are
able to use the different layers at the same time. (However
unfortunately, =with-inner= won't work with my favorite =iterate=
library, since =iter= macro signals an error when it finds 
=macrolet= in the body of the code.)

#+BEGIN_SRC LISP
(defun test0 (flag)
  (with-inner (body)
    (loop for i from 0 to 5
       do (with-inner (body2)
            (loop for j from 0 to 5
                 do
                 (format t "~%i: ~a j: ~a" i j)
                 (inner (body2)
                   (if (evenp i)
                       (body2 (format t "  i is even"))
                       (body2 (format t "  i is odd"))))
                 (inner (body)
                   (if flag
                       (body (format t "  loop on"))
                       (body (format t "  loop off")))))))))
#+END_SRC

** Using other kinds of clauses

Once you have understood how it works, you don't have to be afraid of
using other conditional clauses like cond, case, etc. All you have to
do is calling =label= . This =label= can be interpreted as a
compile-time continuation. It may sound odd but everything's in the
right place isnt it?

#+BEGIN_SRC LISP
(defun test2 (arg)
  (let ((count 0))
    (with-inner (body)
      (iter
        (for i from 0 to 5)
        (inner (body)
          (case (progn (incf count)
                       (mod arg 3))
            (0 (body (format t "divided. i*3 =~a~%"
                             (* i 3))))
            (1 (body (format t "modulo 1. i*3 + 1 =~a~%"
                             (+ 1 (* i 3)))))
            (2 (body (format t "modulo 2. i*3 + 2 =~a~%"
                             (+ 2 (* i 3)))))))))
    (is count 1 "the condition is checked only once")))

(test2 0)
(test2 1)
(test2 2)
#+END_SRC

** And more

OK, you may want to use a normal-looking clauses similar to =when= or
=cond= and not to use a combination of =inner= and local macro bounded
to =label=. In that case, use =inner-when= or =inner-if= etc.

: (inner-if label condition then else)
: (inner-when label condition &body body)
: (inner-cond label &body clauses)
: (inner-case label keyform &body cases)
: (inner-ecase label keyform &body cases)
: (inner-ccase label keyform &body cases)
: (inner-typecase label keyform &body cases)

similar macros can be defined with =define-inner-conditional=.

Usage Example:

#+BEGIN_SRC LISP
(define-inner-conditional inner-when label (condition &body body)
  `(when ,condition
	 (,label ,@body)))
#+END_SRC

Then the macroexpantion of

#+BEGIN_SRC LISP
(inner-when label <condition>
  (dosomething)
  (dosomething))
#+END_SRC

is

#+BEGIN_SRC LISP
(INNER (LABEL)
  (WHEN <CONDITION>
    (LABEL (DOSOMETHING)
           (DOSOMETHING))))
#+END_SRC

Just simple. Simple!
If you have any question with how it works, try some macroexpand-1,
or C-c C-m (slime-expand-1).

* Copyright

Copyright (c) 2013 Masataro Asai (guicho2.71828@gmail.com)


* License

Licensed under the LLGPL License.

