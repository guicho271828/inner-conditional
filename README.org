* Inner-Conditional

 - Series of macros which optimize the inner conditional jumps
   of looping, iterating, anything
 - Extensible syntaxes and helper macros
 - A kind of idea as `compile-time continuation'

** Usage

The condition checking is done only once.
#+BEGIN_SRC LISP
(ql:quickload :iterate)
(use-package :iterate)

(defun test0 (flag)
  (with-inner (body)
    (iter (for i from 0 to 5)
          (print i)
          (inner (body)
            (if flag
                (body (princ "loop on"))
                (body (princ "loop off")))))))

INNER-CONDITIONAL-TEST> (test0 t)

0 loop on
1 loop on
2 loop on
3 loop on
4 loop on
5 loop on
#+END_SRC

** Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.1.2 on X86-64 Linux  3.2.0-39-generic (author's environment)

Also, it depends on the following libraries:

+ ITERATE  ::
    Jonathan Amsterdam's iterator/gatherer/accumulator facility

+ ALEXANDRIA  ::
    Alexandria is a collection of portable public domain utilities.

+ CL-ANNOT by Tomohiro Matsuyama ::
    Python-like Annotation Syntax for Common Lisp

+ CL-SYNTAX by m2ym ::
    Reader Syntax Coventions for Common Lisp and SLIME

+ Optima by m2ym :: 
    Optimized Pattern Matching Library for Common Lisp
    
** Installation

+ First grab the code with =git clone git://github.com/guicho271828/inner-conditional.git=
+ Put it in your local-project folder
+ open slime REPL
+ =(ql:register-local-projects)=
+ =(ql:quickload :inner-conditional)= and the library will be
  installed along with the dependencies

** Author

+ Masataro Asai (guicho2.71828@gmail.com)


* Concepts and API

Removing conditional jumps in loops are one of the easiest way to
optimize the loop. The number of checks should be minimized, and the
checking variables in a smaller loop may well be a large
bottleneck. Yet, some code would yield a bad-looking result of that
optimization, since the semantics of the code best fits the code which
has conditional jumps in a smaller loop. Luckily, Common Lisp has
macros, which provides the ability to walk on and modify the code
tree. So we can keep the code clean and at the same time get a
faster result.

For more details, see [[concepts-and-api.org][Concepts and API]]

* Use with your own library

If you write a macro which expands to a code which always checks a
certain dynamic variable then this library may help you write an
extension which minimizes the number of checking in the expanded code.

For more details, see [[https://github.com/guicho271828/inner-conditional/blob/master/use-with-your-own-library.org][Use with your own library]]

* Copyright

Copyright (c) 2013 Masataro Asai (guicho2.71828@gmail.com)


* License

Licensed under the LLGPL License.

